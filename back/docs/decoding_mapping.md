## Инструкция по созданию сервиса декодирования на FastAPI

### Архитектура сервиса

#### Основные компоненты

1. API endpoints — эндпоинты для приема данных
2. Decoder service — логика декодирования protobuf
3. Mapping service — управление маппингом участников
4. Storage/cache — хранение маппинга (Redis/память)
5. Dependencies — зависимости (pako, protobuf)

---

### Эндпоинты API

#### 1. POST `/api/meetings/{meeting_id}/participants`
Назначение: синхронизация маппинга участников от расширения

Запрос:
- `meeting_id` — ID встречи (path параметр)
- Body (JSON):
  - `session_id` — ID сессии встречи
  - `space_id` — space ID из Google Meet (опционально)
  - `participants` — массив участников:
    - `device_id` — основной ID устройства
    - `name` — имя участника
    - `variants` — массив вариантов device_id
  - `timestamp` — время синхронизации

Ответ:
- 200 OK — маппинг сохранен
- 400 — неверный формат данных
- 401 — проблема с авторизацией

Логика:
- Сохраняет маппинг в кэш (в памяти/Redis)
- Создает индекс для быстрого поиска по всем вариантам device_id
- Обновляет существующий маппинг или создает новый

---

#### 2. POST `/api/meetings/{meeting_id}/raw-transcript`
Назначение: получение RAW данных транскрипта для декодирования

Запрос:
- `meeting_id` — ID встречи (path параметр)
- Body (JSON):
  - `raw_data` — base64 строка с сырыми данными
  - `label` — метка канала ("captions" или "meet_messages")
  - `session_id` — ID сессии
  - `space_id` — space ID (опционально)
  - `timestamp` — время получения данных

Ответ:
- 200 OK с телом:
  - `success: true`
  - `decoded: {...}` — декодированные данные (если успешно)
  - `saved: true/false` — сохранен ли сегмент
- 400 — ошибка декодирования/декомпрессии
- 401 — проблема с авторизацией

Логика:
1. Декодирует base64 → ArrayBuffer
2. Декомпрессирует через pako (gzip)
3. Декодирует protobuf → извлекает `device_id`, `message_id`, `text`, `version`, `lang_id`
4. Ищет имя в маппинге по `device_id` (и его вариантам)
5. Сохраняет сегмент в БД
6. Возвращает результат декодирования

---

#### 3. GET `/api/meetings/{meeting_id}/participants`
Назначение: получение текущего маппинга участников (опционально, для отладки)

Запрос:
- `meeting_id` — ID встречи (path параметр)

Ответ:
- 200 OK с телом:
  - `participants: [...]` — список участников с маппингом
  - `last_updated` — время последнего обновления
- 404 — маппинг не найден

---

#### 4. DELETE `/api/meetings/{meeting_id}/participants` (опционально)
Назначение: очистка маппинга при завершении встречи

---

### Логика декодирования (Decoder Service)

#### Шаги обработки RAW данных

Шаг 1: Подготовка данных
- Принять base64 строку
- Декодировать base64 → получить ArrayBuffer/Uint8Array
- Проверить размер данных

Шаг 2: Декомпрессия
- Проверить magic numbers gzip (31, 139)
- Если gzip — распаковать через pako.inflate()
- Если первые 3 байта не gzip, попробовать пропустить их и проверить снова
- Обработать ошибки декомпрессии

Шаг 3: Декодирование protobuf
- Найти начало данных (байт 16 + 1)
- Извлечь device_id (между байтом 3 и следующим байтом 16)
- Найти границу message_id через паттерны:
  - `[24, 0, 32, 1, 45, 0]`
  - `[24, 0, 1, 32, 1, 45, 0]`
  - `[24, 0, 45, 0]`
  - `[24, 0, 1, 45, 0]`
- Извлечь message_id (little-endian из байтов)
- Извлечь message_version
- Найти текст (между паттернами 50 и 64)
- Извлечь lang_id (после паттерна [64, 0, 72] или [64, 0, 80])
- Декодировать текст как UTF-8

Шаг 4: Валидация
- Проверить наличие device_id и text
- Проверить валидность message_id
- Отсечь дубликаты через кэш сообщений

Шаг 5: Маппинг имени
- Очистить device_id от спецсимволов (начальные \x00-\x1F)
- Поиск в кэше маппинга:
  1. Прямой поиск по device_id
  2. Поиск по очищенному device_id
  3. Извлечение части после "devices/" и поиск
  4. Поиск по последней части пути
  5. Поиск по всем вариантам из маппинга
- Если не найдено — использовать "Unknown (последние 4 символа)"

Шаг 6: Сохранение
- Сформировать payload:
  - `meeting_id`
  - `session_id`
  - `device_id`
  - `username` (из маппинга или "Unknown")
  - `text`
  - `message_id`
  - `version`
  - `lang_id`
  - `timestamp`
  - `composite_id` (для дедупликации)
- Сохранить в БД (через существующий API или напрямую)

---

### Логика маппинга (Mapping Service)

#### Структура хранения маппинга

В памяти/Redis:
```
Ключ: f"meeting:{meeting_id}:participants"
Значение: {
  "device_id_1": {
    "name": "Иван Иванов",
    "variants": ["devices/123", "123", "spaces/xxx/devices/123", ...],
    "updated_at": "2025-01-01T12:00:00Z"
  },
  "device_id_2": {...},
  ...
}

Дополнительный индекс для быстрого поиска:
Ключ: f"meeting:{meeting_id}:index:{variant}"
Значение: "device_id_1"
```

#### Операции с маппингом

1. Сохранение маппинга
   - При получении от расширения
   - Сохранить каждый device_id → имя
   - Создать индекс для всех вариантов
   - Обновить `updated_at`

2. Поиск имени по device_id
   - Проверить прямой ключ
   - Проверить индекс по вариантам
   - Вернуть имя или None

3. Очистка маппинга
   - При завершении встречи
   - Или по TTL (например, через 24 часа)

---

### Кэширование и дедупликация

#### Кэш сообщений (для дедупликации)

Структура:
```
Ключ: f"meeting:{meeting_id}:messages:{message_id}/{device_id}"
Значение: {
  "text": "...",
  "version": 1,
  "processed_at": "..."
}
TTL: 1 час
```

Логика:
- Перед сохранением проверять кэш
- Если текст совпадает — пропустить
- Если отличается — обновить и сохранить

---

### Обработка ошибок

#### Типы ошибок и действия

1. Ошибка декомпрессии
   - Логировать
   - Вернуть 400 с описанием
   - Не сохранять сегмент

2. Ошибка декодирования protobuf
   - Логировать RAW данные для отладки
   - Вернуть 400 с описанием
   - Можно сохранить RAW данные для анализа

3. Маппинг не найден
   - Использовать "Unknown"
   - Сохранить сегмент
   - Логировать предупреждение

4. Неверный формат данных
   - Проверить структуру JSON
   - Проверить base64
   - Вернуть 400 с описанием

---

### Производительность и масштабируемость

#### Рекомендации

1. Асинхронная обработка
   - Использовать FastAPI background tasks
   - Не блокировать ответ при сохранении в БД

2. Батчинг
   - Возможность принимать массив RAW данных
   - Обрабатывать батчами для эффективности

3. Rate limiting
   - Ограничить частоту запросов от одного клиента
   - Защита от спама

4. Мониторинг
   - Метрики: количество декодирований, успешность, время обработки
   - Алерты при высокой частоте ошибок

---

### Схема данных

#### Формат для `/participants`

```json
{
  "session_id": "1234567890",
  "space_id": "abc123",
  "participants": [
    {
      "device_id": "devices/12345",
      "name": "Иван Иванов",
      "variants": [
        "devices/12345",
        "12345",
        "spaces/abc123/devices/12345",
        "\u001espaces/abc123/devices/12345"
      ]
    }
  ],
  "timestamp": "2025-01-01T12:00:00Z"
}
```

#### Формат для `/raw-transcript`

```json
{
  "raw_data": "H4sIAAAAAAAA...",
  "label": "captions",
  "session_id": "1234567890",
  "space_id": "abc123",
  "timestamp": "2025-01-01T12:00:00Z"
}
```

#### Ответ декодирования

```json
{
  "success": true,
  "decoded": {
    "device_id": "devices/12345",
    "message_id": "123",
    "text": "Привет всем",
    "version": 1,
    "lang_id": 0,
    "username": "Иван Иванов"
  },
  "saved": true
}
```

---

### Порядок развертывания

1. Установка зависимостей
   - FastAPI, uvicorn
   - pako (pako.js или python-аналог)
   - protobuf библиотека (если используется)
   - Redis (если для кэша)

2. Структура проекта
   - `/api/routers/` — эндпоинты
   - `/services/decoder.py` — логика декодирования
   - `/services/mapping.py` — логика маппинга
   - `/utils/` — утилиты (base64, compression)
   - `/models/` — модели данных (Pydantic)

3. Конфигурация
   - URL БД для сохранения сегментов
   - Redis настройки (если используется)
   - TTL для кэшей
   - Лимиты rate limiting

4. Тестирование
   - Unit тесты для декодирования
   - Integration тесты для эндпоинтов
   - Тесты с реальными данными от расширения
  